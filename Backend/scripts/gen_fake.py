# Script for Generating Fake Profiles to Demo Matching and Swiping

import requests
import random
from faker import Faker
import os, sys
from marshmallow import ValidationError


# Import DB and Marshmallow Instances
from Backend.src.extensions import db, ma
import Backend.src.routes as routes
import logging

# Import the Models and Schemas

#from src.models import User, Match, Swipe, Message
import Backend.src.models as models

from Backend.app import app # Import the Flask App from app.py


# TODO: Coordinate with User Model
# TODO: Add More Fields to User Model - Image, Bio, Prompts, etc
# TODO: Ensure that user1.email and user2.email are Valid and Return Correctly
#   - May need to Parse to_dict Repr for Proper Return


# Generates Fake User Data and Actions for Demo Purposes

user_schema = models.user.UserSchema()
match_schema = models.match.MatchSchema()
swipe_schema = models.swipe.SwipeSchema()


message_schema = models.message.MessageSchema()
message_schema_nested = models.message.MessageSchemaNested()
message_schema_filtered = models.message.MessageSchemaOnlyEmails(only=(
    'messager', 
    'messagee', 
    'message_content'))

class GenFake():
    
    # Init Faker Instance, Seed Locale
    def __init__(self):
        Faker.seed(random.randint(0, 1000))
        self.fake = Faker()

    # Generate Singular Fake User
    def gen_fake_user(self):
        
        user_schema = models.user.UserSchema()
    
        # Generate a Fake User Dictionary
        user = models.user.User()
        
        #print(dir(user))

        # for each Field in Model, Generate a Fake Value
        # Add the Fake Value to the User Dictionary
        # ID is Auto-Generated by DB
        
        user.email = self.fake.unique.email()
        user.name = self.fake.name()
        user.username = self.fake.user_name()
        
        # Randomly Assign Gender
        # TODO: Probabilistics Weight
        user.gender = self.fake.random_element(elements=('Male', 'Female', 'Other'))
        user.age = self.fake.random_int(min=18, max=100)
        
        user.fake = True
                
        #User ID is Auto-Generated by DB - Do Not Need to Set
        #user.id = None
        
        #BUG: Type object 'User' has no attribute '_meta' - Deprecate if Necessary
        #for field in models.User._meta.fields:
            #fake_value = self.fake_value_for_field(field)
            #setattr(user, field.name, fake_value)
        
        # Set Fake User Flag to True
       # user.fake = True
       
       # models.db.session.add(user)
            
        return user

    # Get All Fake Users from DB
    def get_fake_users(self):
        return  models.user.User.query.filter_by(fake=True).all()

    # Get Two Unique Sampled Fake Users from DB, Ensure they are not Already Matched
    def get_two_fake_users(self):
     
        pair_users = tuple(random.sample(self.get_fake_users(), 2)) # Get Two Random Users
        return pair_users

    # Check if User1 and User2 are already Matched
    def is_matched(self,user1, user2):
        
        # Get All Matches of User1 and User2
        user1_matches =  models.match.Match.query.filter_by(matcher=user1.id).all()
        user2_matches =  models.match.Match.query.filter_by(matchee=user2.id).all()
        
        # Check if user2 is in user1's Matches or vice versa
        return self._is_related(user1, user2, "match", user1_matches) or self._is_related(user1, user2, "match", user2_matches)

    # Check is User1 and User2 are Swiped by Each Other
    def is_swiped(self,user1, user2):

        # Get All Swipes of User1 and User2
        user1_swipes =  models.swipe.Swipe.query.filter_by(swiper=user1.email).all()
        user2_swipes =  models.swipe.Swipe.query.filter_by(swipee=user2.email).all()
        
        # Check if user2 is in user1's Swipes or vice versa
        return self._is_related(user1, user2, "swipe", user1_swipes) or self._is_related(user1, user2, "swipe", user2_swipes)

    # Check if User1 and User2 are Related by a Particular Relationship
    # Used for Matches and Swipes Relationship Check
    def _is_related(self,user1, user2, relationship, relations):
        
        # Check if user2 is in user1's Relations
        # Parse JSON Response for Proper Re
        for relation in relations:
            if relations[relationship + "er"] == user1.id and relations[relationship + "er"] == user2.id:
                return True
        return False

    # Generates Fake Match between two Faked Users
    # Constraints - Matcher and Matchee are Different Users
    #             - Collision of Match Objects is Possible (if Matcher and Matchee are already Matched)     
    def gen_fake_match(self, matcher, matchee):
        while True:
            if not self.is_matched(matcher, matchee):
                match = models.match.Match(matcher=matcher.id, matchee=matchee.id, match_date=self.fake.date_time())
                return match
            else:
                match = db.session.query(models.match.Match).filter_by(matcher=matcher.id, matchee=matchee.id).first()
                match = match_schema.load(match)
            return match
    # Generates Fake Swipe between two Faked Users
    def gen_fake_swipe(self,swiper,swipee):
        
        
        # Create a Swipe Object
        # Will not Function Properly without Correct Model Mapping in ORM (Refer to models.py)
        swipe = models.swipe.Swipe(swiper=swiper.id, 
                                   swipee=swipee.id, 
                                   swipe_result=models.swipe.SwipeResult(self.fake.random_int(min=0, max=2)),
                                   swipe_date=self.fake.date_time())
        return swipe
        
    def gen_fake_message(self, messager, messagee):
        
        # Create a Message Object
        message = models.message.Message(messager=messager, 
                                         messagee=messagee, 
                                         message_content=self.fake.text(max_nb_chars=200), 
                                         message_date=self.fake.date_time())
        
        return message
    
    def gen_fake_conversation(self, user1, user2, num_messages=20):
              
        conversation = [] # List of Messages in Conversation      
            
        # Generate 20 Fake Messages Between Two Users                            
        for _ in range(num_messages):
            
            # Randomly Select Sender and Receiver
            rand_choice_sender = random.choice([user1, user2])
            rand_choice_receiver = user1 if rand_choice_sender == user2 else user2

            try:
                
                # Construct Message Instance Between Users
                message = self.gen_fake_message(rand_choice_sender, rand_choice_receiver)
                
            except Exception as e:
                logging.error(f"Error Generating Fake Message for Conversation: {e}")
                continue
            
            conversation.append(message) # Add Message to Conversation
            
        logging.info("Fake Conversation Generated Successfully!")
        return conversation
    
    def gen_num_fake_users(self, num_users=100):
            
            users = []
            for _ in range(int(num_users)):
                user = self.gen_fake_user()
                users.append(user)
            return users
    
    def add_fake_users_to_db(self,users,num_users=100):
        
        try:
           
            for user in users:
                
                user_in_db = db.session.query(models.user.User).filter_by(email=user.email).first()
                
                if not user_in_db:
                    db.session.add(user)

            db.session.commit()
            db.session.flush(users)
            
        except Exception as e:
            logging.error(f"Error Adding Fake Users to DB: {e}")
            return False
        
        logging.info(f"Fake User Added to DB: {user_schema.dump(user)}")
        return True
        
    # Generates Fake Value for a Particular Field of a Data Model ORM
    # BUG: Refer to Bug in gen_fake_user -  Functionality Deprecated As of Now
    def _fake_value_for_field(self,field):
        
        # Dictionary of Faker Functions for Each Field Type
        fake_funcs = {
            'Name': self.fake.name(),
            'Email': self.fake.email(), # Add Fake Descriptor to Email, Possibly Collisions with Real Emails
            'DateTimeField': self.fake.date_time(),
            'Boolean': self.fake.boolean(),
            'Integer': self.fake.random_int()
        }
        
        # Return the Fake Value for the Field, or None if not found
        return fake_funcs[field.__class__.__name__]()

    def gen_write_users_to_csv_db(self):
           
        # Generate 100 Fake Users and store in CSV file
        test_fake_users = [self.gen_fake_user() for _ in range(100)]
        
        # Write the Generated Fake Users to CSV
        # data_path is the path to a data holding directory - Child of Backend
        data_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'data'))
        csv_f = data_path + '/fake_users.csv'
        
        with open(csv_f, 'a') as f:
            
            for user in test_fake_users:
                try:
                    # Validate the User Data
                    user_schema.load(user_schema.dump(user))
                    
                    with app.app_context():
                        db.session.add(user) # Add the User to the DB
                        #db.session.flush() # Flush the session to generate the primary key id
                        
                        db.session.commit()
                        db.session.refresh(user)
                    
                except ValidationError as e:
                    print(f"Error: {e}")
                    continue
                
                f.write(str(user_schema.dump(user)))
                f.write("\n")
                print("Fake Users Generated and Stored in DB")





# Set up Log File Path as ../logs/fake_profiles.log
log_file_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'logs', 'fake_profiles.log'))

# Set up logging configuration
logging.basicConfig(filename=log_file_path, level=logging.INFO)


# Main Function
if __name__ == '__main__':

    
    # Get CLI Args: 
    # - Gen Fake Users (--gen-fake-users)
    # - Gen Fake Conversations (--gen-fake-conversations)
    # - Gen Fake Matches (--gen-fake-matches)
    # - Gen Fake Swipes (--gen-fake-swipes)
    # - Gen Fake Messages (--gen-fake-messages)
    # - Gen Fake All (--gen-fake-all)
    
    
    # If No Args, Exit
    if len(sys.argv) == 1:
        print("No CLI Arguments Provided")
        exit(1)
        
    Generator = GenFake()
    
    # Parse CLI Arguments
    args = sys.argv[1:]
    
    if "--reset-db" in args:
            with app.app_context():
                db.drop_all()
                db.create_all()
    
    # Check for specific arguments and perform corresponding actions
    if "--gen-fake-users" in args:
        
        with app.app_context():
            Generator.gen_add_fake_users_to_db(num_users=100)
    
    if "--gen-fake-conversations" in args:
        
        for _ in range(25):
            
            with app.app_context():
                
                user1, user2 = Generator.get_two_fake_users()
                conversation = Generator.gen_fake_conversation(user1, user2, num_messages=10)
                
                for message in conversation:
                    db.session.add(message)
                
                db.session.commit()
    
    if "--gen-fake-matches" in args:
        # Generate fake matches
        
        matches = []
        for _ in range(25):
            
            with app.app_context():
                
                user1, user2 = Generator.get_two_fake_users()
                match = Generator.gen_fake_match(user1, user2)
                matches.append(match)
                
        
        db.session.add_all(matches)
        db.session.commit()
    
    #if "--gen-fake-swipes" in args:
        # Generate fake swipes
        
        #user1, user2 = Generator.get_two_fake_users()
        #swipe1 = Generator.gen_fake_swipe(user1, user2)
        
        #pass
    
    # Generate  100 Fake Messages Between Two Sampled Fake Users
    if "--gen-fake-messages" in args:
        
        messages = []
        
        for _ in range(100):
            
            with app.app_context():
                
                # Generate fake messages
                # get Two Random Users
                user1, user2 = Generator.get_two_fake_users()
                message = Generator.gen_fake_message(user1, user2)
                messages.append(message)
        
        # Bulk Add and Commit
        db.session.add_all(messages)
        db.session.commit()
    

    #Generator.gen_write_users_to_csv_db()
