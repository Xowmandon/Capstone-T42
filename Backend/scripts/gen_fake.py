# Script for Generating Fake Profiles to Demo Matching and Swiping

import requests
import random
from faker import Faker
import os, sys
from marshmallow import ValidationError


# Import DB and Marshmallow Instances
from Backend.src.extensions import db, ma
from Backend.src import routes

# Import the Models and Schemas

#from src.models import User, Match, Swipe, Message
import Backend.src.models as models

from Backend.app import app # Import the Flask App from app.py


# TODO: Coordinate with User Model
# TODO: Add More Fields to User Model - Image, Bio, Prompts, etc
# TODO: Ensure that user1.email and user2.email are Valid and Return Correctly
#   - May need to Parse to_dict Repr for Proper Return


# Generates Fake User Data and Actions for Demo Purposes

user_schema = models.user.UserSchema()
match_schema = models.match.MatchSchema()

class GenFake():
    
    # Init Faker Instance, Seed Locale
    def __init__(self):
        Faker.seed(random.randint(0, 1000))
        self.fake = Faker()

    # Generate Singular Fake User
    def gen_fake_user(self):
        
        user_schema = models.user.UserSchema()
    
        # Generate a Fake User Dictionary
        user = models.user.User()
        
        #print(dir(user))

        # for each Field in Model, Generate a Fake Value
        # Add the Fake Value to the User Dictionary
        # ID is Auto-Generated by DB
        
        user.email = self.fake.email()
        user.name = self.fake.name()
        user.username = self.fake.user_name()
        
        # Randomly Assign Gender
        # TODO: Probabilistics Weight
        user.gender = self.fake.random_element(elements=('Male', 'Female', 'Other'))
        user.age = self.fake.random_int(min=18, max=100)
        
        user.fake = True
                
        #User ID is Auto-Generated by DB - Do Not Need to Set
        #user.id = None
        
        #BUG: Type object 'User' has no attribute '_meta' - Deprecate if Necessary
        #for field in models.User._meta.fields:
            #fake_value = self.fake_value_for_field(field)
            #setattr(user, field.name, fake_value)
        
        # Set Fake User Flag to True
       # user.fake = True
       
       # models.db.session.add(user)
            
        return user

    # Get All Fake Users from DB
    def get_fake_users(self):
        return  models.user.User.query.filter_by(fake=True).all()

    # Get Two Unique Sampled Fake Users from DB, Ensure they are not Already Matched
    def get_two_fake_users(self):
     
        pair_users = tuple(random.sample(self.get_fake_users(), 2)) # Get Two Random Users
        return pair_users

    # Check if User1 and User2 are already Matched
    def is_matched(self,user1, user2):
        
        # Get All Matches of User1 and User2
        user1_matches =  models.match.Match.query.filter_by(matcher=user1.email).all()
        user2_matches =  models.match.Match.query.filter_by(matchee=user2.email).all()
        
        # Check if user2 is in user1's Matches or vice versa
        return self._is_related(user1, user2, "match", user1_matches) or self._is_related(user1, user2, "match", user2_matches)

    # Check is User1 and User2 are Swiped by Each Other
    def is_swiped(self,user1, user2):

        # Get All Swipes of User1 and User2
        user1_swipes =  models.swipe.Swipe.query.filter_by(swiper=user1.email).all()
        user2_swipes =  models.swipe.Swipe.query.filter_by(swipee=user2.email).all()
        
        # Check if user2 is in user1's Swipes or vice versa
        return self._is_related(user1, user2, "swipe", user1_swipes) or self._is_related(user1, user2, "swipe", user2_swipes)

    # Check if User1 and User2 are Related by a Particular Relationship
    # Used for Matches and Swipes Relationship Check
    def _is_related(self,user1, user2, relationship, relations):
        
        # Check if user2 is in user1's Relations
        # Parse JSON Response for Proper Re
        for relation in relations:
            if relations[relationship + "er"] == user1.email and relations[relationship + "er"] == user2.email:
                return True
        return False

    # Generates Fake Match between two Faked Users
    # Constraints - Matcher and Matchee are Different Users
    #             - Collision of Match Objects is Possible (if Matcher and Matchee are already Matched)     
    def gen_fake_match(self, matcher, matchee):
        while True:
            if not self.is_matched(matcher, matchee):
                match = models.match.Match.Match(matcher=matcher, matchee=matchee, match_date=self.fake.date_time())
                return match
        
        
    # Generates Fake Swipe between two Faked Users
    def gen_fake_swipe(self,swiper,swipee):
        
        # Create a Swipe Object
        # Will not Function Properly without Correct Model Mapping in ORM (Refer to models.py)
        swipe = models.swipe.Swipe(swiper=swiper, swipee=swipee, swipe_result=random.choice([1, 0]), swipe_date=self.fake.date_time())
        
        return swipe
        
    def gen_fake_message(self, messager, messagee):
        
        # Create a Message Object
        message = models.message.Message(messager=messager, 
                                         messagee=messagee, 
                                         message_text=self.fake.text(max_nb_chars=200), 
                                         message_date=self.fake.date_time())
        
        return message
    
    def gen_fake_conversation(self, user1, user2):
              
        # Get Two Fake Users - a Pair
        pair = (user1, user2)      
                
        try:
        
            for users in pair:
                if not db.session.query(models.user.User).filter_by(email=users.email).first():
                    db.session.add(users)
                    db.session.commit()
                    db.session.refresh(users)
        
    
        except Exception as e:
            print(f"Error: {e}")
            return None
        
                    
        for _ in range(20):
            
            # Randomly Select Sender and Receiver
            rand_choice_sender = random.choice(pair)
            rand_choice_receiver = user1 if rand_choice_sender == user2 else user2
            
            # Construct Message Instance Between Users
            message = self.gen_fake_message(rand_choice_sender, rand_choice_receiver)
            
            # Add to DB
            models.db.session.add(message)
            
            # Commit Changes
            models.db.session.commit()
            
        
    # Generates Fake Value for a Particular Field of a Data Model ORM
    # BUG: Refer to Bug in gen_fake_user -  Functionality Deprecated As of Now
    def _fake_value_for_field(self,field):
        
        # Dictionary of Faker Functions for Each Field Type
        fake_funcs = {
            'Name': self.fake.name(),
            'Email': self.fake.email(), # Add Fake Descriptor to Email, Possibly Collisions with Real Emails
            'DateTimeField': self.fake.date_time(),
            'Boolean': self.fake.boolean(),
            'Integer': self.fake.random_int()
        }
        
        # Return the Fake Value for the Field, or None if not found
        return fake_funcs[field.__class__.__name__]()

    def gen_write_to_csv_db(self):
           
        # Generate 100 Fake Users and store in CSV file
        test_fake_users = [self.gen_fake_user() for _ in range(100)]
        
        # Write the Generated Fake Users to CSV
        # data_path is the path to a data holding directory - Child of Backend
        data_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'data'))
        csv_f = data_path + '/fake_users.csv'
        
        with open(csv_f, 'a') as f:
            
            for user in test_fake_users:
                try:
                    # Validate the User Data
                    user_schema.load(user_schema.dump(user))
                    
                    with app.app_context():
                        db.session.add(user) # Add the User to the DB
                        #db.session.flush() # Flush the session to generate the primary key id
                        
                        db.session.commit()
                        db.session.refresh(user)
                    
                except ValidationError as e:
                    print(f"Error: {e}")
                    continue
                
                f.write(str(user_schema.dump(user)))
                f.write("\n")
                print("Fake Users Generated and Stored in DB")



# Main Function
if __name__ == '__main__':
   
    Generator = GenFake()
    pair = Generator.get_two_fake_users()

    # Generate a Fake Match Between Two Users
    match = Generator.gen_fake_match()
    
    # Generate a Fake Swipe Between Two Users
    swipe = Generator.gen_fake_swipe(pair[0], pair[1])
    
    # Generate a Fake Conversation Between Two Users
    Generator.gen_fake_conversation(pair[0], pair[1])
    
    """
    with app.app_context():
        #print(db.session.query(models.user.User).all())
        for user in db.session.query(models.user.User).all():
            if user is not None:
                print(user_schema.dump(user))
                print("\n")


    # Get Two Random Fake Users
    pair_users = tuple(random.sample(test_fake_users, 2))
    
    # Generate a Fake Match between the Two Users
    match = models.match.Match(matcher=pair_users[0], matchee=pair_users[1], match_date=UserGenerator.fake.date_time())
    
    # Validate the Match Data Against the Match Schema
    match_schema = models.match.MatchSchema(only=('matchee', 'match_date'))
    #print(match_schema.dump(match))
    """
